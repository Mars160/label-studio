name: "On Premise: Cut off release branch"

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version'
        required: true
        type: string
      ref:
        description: 'Commit SHA or ref name or tag'
        required: true
        default: 'develop'
        type: string

env:
  PYTHON_VERSION_FILE: "label_studio/__init__.py"
  RELEASE_BRANCH_PREFIX: "lse-release"

jobs:
  draft-new-release:
    name: "On Premise: Cut off release branch"
    runs-on: ubuntu-latest
    steps:
      - uses: hmarr/debug-action@v2.0.1

      - name: Checkout
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GIT_PAT }}
          ref: ${{ github.event.inputs.ref }}
          submodules: 'recursive'
          fetch-depth: 0

      - name: Configure git
        shell: bash
        run: |
          set -xeuo pipefail
          git config --global user.name 'robot-ci-heartex'
          git config --global user.email 'robot-ci-heartex@users.noreply.github.com'

      - name: Calculate branch name and version
        id: calculate_branch_name_and_version
        shell: bash
        run: |
          set -xeuo pipefail
          
          regexp='^[v]?([0-9]+)\.([0-9]+)\.([0-9]+)$';
          
          if [[ "${{ inputs.version }}" =~ $regexp ]]; then
              first="${BASH_REMATCH[1]}"
              second="${BASH_REMATCH[2]}"
              third="${BASH_REMATCH[3]}"
          else
              echo "${{ inputs.version }} does not mach the regexp ${regexp}"
              exit 0
          fi
          
          release_version="${first}.${second}.${third}"
          release_branch="${{ env.RELEASE_BRANCH_PREFIX }}/${first}.${second}.${third}"
          next_develop_version="${first}.${second}.$(($third + 1)).dev"
          
          echo "::set-output name=release_branch::${release_branch}"
          echo "::set-output name=release_version::${release_version}"
          echo "::set-output name=next_develop_version::${next_develop_version}"

      - name: Cut dependencies release branches
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GIT_PAT }}
          script: |
            const { repo, owner } = context.repo;
            const ref = '${{ inputs.ref }}'
            const release = '${{ steps.calculate_branch_name_and_version.outputs.release_branch }}'

            let submodules = [
                {owner: 'heartexlabs', repo: 'label-studio-private'},
                {owner: 'heartexlabs', repo: 'label-studio-frontend'},
                {owner: 'heartexlabs', repo: 'dm2'},
                {owner: 'heartexlabs', repo: 'label-studio'},
                {owner: 'heartexlabs', repo: 'label-studio-evalme'}
            ]

#            async function getLSESubmoduleVersions(sha) {
#                const {data: lseTreeData} = await github.rest.git.getTree({
#                    owner,
#                    repo,
#                    tree_sha: sha
#                })
#                const {data: lseDeployTreeData} = await github.rest.git.getTree({
#                    owner,
#                    repo,
#                    tree_sha: lseTreeData.tree.find(e => e.path === 'deploy' && e.type === 'tree').sha
#                })
#                const {data: requirementsLSBlobData} = await github.rest.git.getBlob({
#                    owner,
#                    repo,
#                    file_sha: lseDeployTreeData.tree.find(e => e.path === 'requirements-ls.txt' && e.type === 'blob').sha
#                })
#                const requirementsLS = Buffer.from(requirementsLSBlobData.content, requirementsLSBlobData.encoding).toString("utf8")
#                const matchLS = requirementsLS.match('https:\/\/github.com\/heartexlabs\/label-studio\/archive\/(.*)\.zip')
#                const matchEVALME = requirementsLS.match('https:\/\/github\.com\/heartexlabs\/label-studio-evalme\/archive\/(.*)\.zip')
#                return {
#                    'label-studio-private': lseTreeData.tree.find(e => e.path === "label-studio-private").sha,
#                    'label-studio-frontend': lseTreeData.tree.find(e => e.path === "editor").sha,
#                    'dm2': lseTreeData.tree.find(e => e.path === "datamanager").sha,
#                    'label-studio': matchLS[1],
#                    'label-studio-evalme': matchEVALME[1],
#                }
#            }
#
#            const versions = await getLSESubmoduleVersions('${{ inputs.ref }}')
#            console.log(`submodules versions: ${{ inputs.ref }}`)
#            console.log(versions)
            
#            for (let submodule of submodules) {
#                const response = await github.rest.git.createRef({
#                    owner: submodule.owner,
#                    repo: submodule.repo,
#                    ref: `refs/heads/${release}`,
#                    sha: versions[submodule.repo],
#                });
#            }

      - name: Commit version files to release branch
        id: make-release-commit
        run: |
          set -euo pipefail
          
          git checkout -b "${{ steps.calculate_branch_name_and_version.outputs.release_branch }}"
          
          sed -i "s/^__version__[ ]*=.*/__version__ = '${{ steps.calculate_branch_name_and_version.outputs.release_version }}'/g" ${{ env.PYTHON_VERSION_FILE }}
          
          git add ${{ env.PYTHON_VERSION_FILE }}
          git commit --message "ci: cut release ${{ steps.calculate_branch_name_and_version.outputs.release_version }}"

          echo "::set-output name=commit::$(git rev-parse HEAD)"
          git push origin HEAD:refs/heads/${{ steps.calculate_branch_name_and_version.outputs.release_branch }}

      - name: Commit version files to 'develop'
        id: make-develop-commit
        run: |
          set -euo pipefail
          
          git checkout '${{ github.event.repository.default_branch }}'
          
          branch='bump-version-${{ steps.calculate_branch_name_and_version.outputs.next_develop_version }}dev'
          echo "::set-output name=branch::${branch}"
          git checkout -b "${branch}"
          
          sed -i "s/^__version__[  ]*=.*/__version__ = '${{ steps.calculate_branch_name_and_version.outputs.next_develop_version }}dev'/g" ${{ env.PYTHON_VERSION_FILE }}
          
          git add ${{ env.PYTHON_VERSION_FILE }}
          git commit --message "chore: Bump version to ${{ steps.calculate_branch_name_and_version.outputs.next_develop_version }}dev"

          echo "::set-output name=commit::$(git rev-parse HEAD)"
          git push origin HEAD:refs/heads/${branch}

      - name: Create PR to 'develop'
        uses: actions/github-script@v6
        id: create-pr
        with:
          github-token: ${{ secrets.GIT_PAT }}
          script: |
            const { repo, owner } = context.repo;
            const createPullResponse = await github.rest.pulls.create({
              title: 'chore: Bump version to ${{ steps.calculate_branch_name_and_version.outputs.next_develop_version }}dev',
              owner,
              repo,
              head: '${{ steps.make-develop-commit.outputs.branch }}',
              base: '${{ github.event.repository.default_branch }}',
              body: [
                'Hi @${{ github.actor }}!',
                '',
                'This PR was created in response to a manual trigger of the release workflow here: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}.',
              ].join('\n')
            });
            github.rest.pulls.requestReviewers({
              owner,
              repo,
              pull_number: createPullResponse.data.number,
               reviewers: [ '${{ github.actor }}' ]
            });
            return createPullResponse

      - name: Enable AutoMerge
        id: enable-pr-automerge
        shell: bash
        env:
          GIT_PAT: ${{ secrets.GIT_PAT }}
        run: |
          echo "$GIT_PAT" | gh auth login --with-token
          gh api graphql -f pull='${{ fromJson(steps.create-pr.outputs.result).data.node_id }}' -f query='
            mutation($pull: ID!) {
              enablePullRequestAutoMerge(input: {pullRequestId: $pull, mergeMethod: SQUASH}) {
                pullRequest {
                  id
                  number
                }
              }
            }'
#
#      - name: Notify to Slack on draft release
#        id: slack_notify_ops_release
#        uses: slackapi/slack-github-action@v1.19
#        with:
#          channel-id: 'C03F181D2J2'
#          slack-message: |
#            On-Premise Release *${{ steps.calculate_branch_name_and_version.outputs.release_version }}* is coming!
#
#            *Draft Release:* ${{ fromJson(steps.create-draft-release.outputs.result).data.html_url }}
#            *Release branch:* ${{ github.server_url }}/${{ github.repository }}/tree/${{ steps.calculate_branch_name_and_version.outputs.release_branch }}
#            *Version Bump PR:* ${{ fromJson(steps.create-pr.outputs.result).data.html_url }}
#
#            ><https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|[Workflow run]>
#        env:
#          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
